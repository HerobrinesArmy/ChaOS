; --------------------------------------------
; Title:   cluster_manager
; Author:  Liraal
; Date:    2012-07-09
; Version: 0x1
; --------------------------------------------
;This is a complete rewrite of FAT16 code
;Designed for better work with memory manager
;---------------------------------------------

:fs_FAT_number		dat 0x0
:fs_reserved_number	dat 0x0
:fs_FAT_offset		dat 0x1
:fs_root_offset		dat 0x1
:fs_temp_memory		dat 0x0
:fs_FAT_memory		dat 0x0
:fs_drive			dat 0x0
:fs_error_code		dat 0x0 ;0x1 is OOM
:fs_dir_entry		dat 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0

:fs_init		;initializes the filesystem: allocates memory areas, reads the bootsector
set [fs_error_code], 0x0
set push, A
set push, C
set push, X
set A, 0x200
jsr mem_alloc
ife A, 0x0
	set pc, fs_init_oom
set [fs_temp_memory], A
set A, 0x0
set C, 0x1
set X, [fs_temp_memory]
jsr fs_load_to_mem
set A, [fs_temp_memory]
add A, 0x8
set [fs_reserved_number], [A]
add A, 0x1
set [fs_FAT_number], [A]
add A, 0x3
mul [fs_FAT_number], [A]
add [fs_FAT_offset], [fs_reserved_number]
add [fs_root_offset], [fs_reserved_number]
add [fs_root_offset], [fs_FAT_number]
set X, pop
set C, pop
set A, pop
set pc, pop

:fs_init_oom
set [fs_error_code], 0x1
set X, pop
set C, pop
set A, pop
set pc, pop

:fs_load_to_mem	;A - cluster number, X - adress in memory, C -number of clusters to read
set push, A
set push, B
set push, X
add A, [fs_root_offset]
set B, A
set A, 0x10
hwi [fs_drive]
set X, pop
set B, pop
set A, pop
set pc, pop

:fs_write_from_mem	;A - cluster number, X - adress in memory, C - number of clusters to write
set push, A
set push, B
set push, X
add A, [fs_root_offset]
set B, A
set A, 0x11
hwi [fs_drive]
set X, pop
set B, pop
set A, pop
set pc, pop

:fs_get_FAT_entry	;A - starting cluster, output: C - length in clusters
set [fs_error_code], 0x0
set push, A
set push, B
set push, C
set push, X
set push, Y
set B, A
set A, [fs_FAT_number]
mul A, 0x200
jsr mem_alloc
ife A, 0x0
	set pc, fs_get_FAT_entry_oom
set X, A
set C, [fs_FAT_number]
set A, [fs_FAT_offset]
jsr	fs_load_to_mem
add B, X
set C, 0x0
:fs_get_FAT_entry_loop
set Y, B
add Y, C
ife [Y], 0xffff
	set pc, fs_get_FAT_entry_end
add C, 0x1
set pc, fs_get_FAT_entry_loop
:fs_get_FAT_entry_end
set A, X
jsr mem_free
set Y, pop
set X, pop
set C, pop
set B, pop
set A, pop
set pc, pop

:fs_get_FAT_entry_oom
set [fs_error_code], 0x1
set Y, pop
set X, pop
set C, pop
set B, pop
set A, pop
set pc, pop

:fs_get_free_FAT	;A - length of file in clusters, output: A - starting cluster or 0x0 if none found
set [fs_error_code], 0x0
set push, C
set push, I
set push, J
set push, X
set push, A
set A, [fs_FAT_number]	;loading FAT to mem
mul A, 0x200
jsr mem_alloc
ife A, 0x0
	set pc, fs_get_free_FAT_oom
set X, A
set A, [fs_FAT_offset]
set C, [fs_FAT_number]
jsr	fs_load_to_mem
set A, pop
set C, 0x0
set J, 0x0
set I, [fs_FAT_number]
mul I, 0x200
:fs_get_free_FAT_loop	;searching FAT
ife C, A
	set pc, fs_get_free_FAT_end
ife J, I
	set pc, fs_get_free_FAT_none
add J, X
ife [J], 0x0
	add C, 0x1
ifn [J], 0x0
	set C, 0x0
sub J, X
add J, 0x1
set pc, fs_get_free_FAT_loop
:fs_get_free_FAT_none	;no free space found
set J, C
sub J, 0x1
:fs_get_free_FAT_end	;end
sub J, C
add J, 0x1
set A, X
jsr mem_free			;free the memory
set A, J
set X, pop
set J, pop
set I, pop
set C, pop
set pc, pop

:fs_get_free_FAT_oom
set [fs_error_code], 0x1
set A, J
set X, pop
set J, pop
set I, pop
set C, pop
set pc, pop

:fs_create_file		;A - length in clusters, output: A - starting cluster
set [fs_error_code], 0x0
set push, C
set push, J
set push, X
set push, Y
set Y, A
set push, A
set A, [fs_FAT_number]
mul A, 0x200
jsr mem_alloc
ife A, 0x0
	set pc, fs_create_file_oom
set X, A
set A, [fs_FAT_offset]
set C, [fs_FAT_number]
jsr	fs_load_to_mem
set A, pop
jsr fs_get_free_FAT
sub Y, 0x1
set J, 0x0
:fs_create_file_loop
ife J, Y
	set pc, fs_create_file_end
add J, A
add J, X
set [J], J
sub J, X
sub J, A
add J, 0x1
set pc, fs_create_file_loop
:fs_create_file_end
set [J], 0xffff
set push, A
set A, [fs_FAT_offset]
set C, [fs_FAT_number]
jsr fs_write_from_mem
set A, X
jsr mem_free
set A, pop
set Y, pop
set X, pop
set J, pop
set C, pop
set pc, pop

:fs_create_file_oom
set [fs_error_code], 0x1
set A, pop
set Y, pop
set X, pop
set J, pop
set C, pop
set pc, pop

:fs_delete_file		;A - starting cluster
set [fs_error_code], 0x0
set push, C
set push, J
set push, X
set push, Y
set push, A
set A, [fs_FAT_number]
mul A, 0x200
jsr mem_alloc
ife A, 0x0
	set pc, fs_delete_file_oom
set X, A
set A, [fs_FAT_offset]
set C, [fs_FAT_number]
jsr	fs_load_to_mem
set A, pop
jsr fs_get_FAT_entry
set J, 0x0
:fs_delete_file_loop
ife J, C
	set pc, fs_delete_file_end
add J, A
add J, X
set [J], 0x0
sub J, X
sub J, A
add J, 0x1
set pc, fs_delete_file_loop
:fs_delete_file_end
set push, A
set A, [fs_FAT_offset]
set C, [fs_FAT_number]
jsr fs_write_from_mem
set A, X
jsr mem_free
set A, pop
set Y, pop
set X, pop
set J, pop
set C, pop
set pc, pop

:fs_delete_file_oom
set [fs_error_code], 0x1
set A, pop
set Y, pop
set X, pop
set J, pop
set C, pop
set pc, pop

:fs_load_file			;A - starting cluster, output: A - adress in memory of the file loaded
set [fs_error_code], 0x0
set push, B
set push, C
set push, X
set push, A
jsr fs_get_FAT_entry
set C, A
mul A, 0x200
jsr mem_alloc
ife A, 0x0
	set pc, fs_load_file_oom
set X, A
set B, pop
set A, 0x10
hwi [fs_drive]
set A, X
set X, pop
set C, pop
set B, pop
set pc, pop

:fs_load_file_oom
set [fs_error_code], 0x1
set A, pop
set X, pop
set C, pop
set B, pop
set pc, pop

:fs_edit_file			;A - starting cluster, X - memory adress
set push, B
set push, C
set push, X
set push, A
jsr fs_get_FAT_entry
set C, A
set B, pop
set A, 0x11
hwi [fs_drive]
set A, B
set X, pop
set C, pop
set B, pop
set pc, pop

:fs_get_dir_entry		;A - starting cluster of dir, B - number of the entry, output: A - adress of the entry
set push, B
jsr fs_load_file
ife [fs_error_code], 0x1
	set pc, fs_get_dir_entry_oom
mul B, 0x10
set push, I
set I, 0x0
:fs_get_dir_entry_loop
ife I, 0x10
	set pc, fs_get_dir_entry_end
add I, fs_dir_entry
set [I], [B]
sub I, fs_dir_entry
add I, 0x1
add B, 0x1
set pc, fs_get_dir_entry_loop
:fs_get_dir_entry_end
set I, pop
set B, pop
jsr mem_free
set A, fs_dir_entry
set pc, pop

:fs_get_dir_entry_oom
set B, pop
set pc, pop

:fs_get_free_dir_entry		;A - starting cluster of dir
set push, B
set push, C
set push, I
set push, J
set push, X
jsr fs_load_file
set X, A
set C, 0x0
set J, 0x0
jsr fs_get_FAT_entry
set I, A
mul I, 0x200
:fs_get_free_dir_entry_loop	;searching dir
ife C, 0x10
	set pc, fs_get_free_dir_entry_end
ife J, I
	set pc, fs_get_free_dir_entry_none
add J, X
ife [J], 0x0
	add C, 0x1
ifn [J], 0x0
	set C, 0x0
sub J, X
add J, 0x1
set pc, fs_get_free_dir_entry_loop
:fs_get_free_dir_entry_none	;no free space found
set J, C
sub J, 0x1
:fs_get_free_dir_entry_end	;end
sub J, C
add J, 0x1
set A, X
jsr mem_free			;free the memory
set A, J
set X, pop
set J, pop
set I, pop
set C, pop
set pc, pop


:fs_add_dir_entry ;A - starting cluster, B - adress of the entry
set push, A
set push, B
set push, C
set push, I
set push, J
set push, X
set push, A
jsr fs_load_file
set X, A
set A, peek
jsr fs_get_free_dir_entry
set J, 0x0
:fs_add_dir_entry_loop
ife J, 0x10
	set pc, fs_add_dir_entry_end
add J, A
add J, X
set [J], [B]
sub J, X
sub J, A
add J, 0x1
add B, 0x1
set pc, fs_add_dir_entry_loop
:fs_add_dir_entry_end
set A, pop
jsr fs_edit_file
set A, X
jsr mem_free
set X, pop
set J, pop
set I, pop
set C, pop
set B, pop
set A, pop
set pc, pop

:fs_remove_dir_entry
set push, A
set push, B
set push, C
set push, I
set push, J
set push, X
set push, A
jsr fs_load_file
set X, A
set A, peek
jsr fs_get_dir_entry
set J, 0x0
:fs_remove_dir_entry_loop
ife J, 0x10
	set pc, fs_remove_dir_entry_end
add J, A
add J, X
set [J], 0x0
sub J, X
sub J, A
add J, 0x1
add B, 0x1
set pc, fs_remove_dir_entry_loop
:fs_remove_dir_entry_end
set A, pop
jsr fs_edit_file
set A, X
jsr mem_free
set X, pop
set J, pop
set I, pop
set C, pop
set B, pop
set A, pop
set pc, pop