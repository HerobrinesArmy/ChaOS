:clrscr
	set push, i
	set push, j
	set j, [VRAM_end]
	set i, [VRAM_end]
	sub i, [VRAM]
	add i, 1
	:__clrscr__loop
	std [j], 0
	ifn i, 0
		set pc, __clrscr__loop
	set j, pop
	set i, pop
	set pc, pop
		
:draw_cell ;takes X as X-coordinate, Y as Y-coordinate, and C for the character to draw
	ifg y, 11
		set pc, pop
	ifg x, 31
		set pc, pop
	set push, y
	shl y, 5
	add y, x
	add y, [VRAM]
	set [y], c
	set y, pop
	set pc, pop

:print  ; takes A as the start of the text, and B is text color (0 == NONE)
	set push, a
	set push, i
	set push, j
	
	; Switch from A to I, so that STI instructions can be used.
	set i, a
	set j, [video_cur]
	:__print__loop
	set a, [i]
	ife a, 0																																	
		set pc, __print__done
	bor a, b
	sti [j], a
	ife j, 0x9180
		jsr scroll
	set pc, __print__loop
	:__print__done
	set [video_cur], j
	jsr enter
	set j, pop
	set i, pop
	set a, pop
	set pc, pop
 
:printc ; Takes A as the character to print
	set push, j
	set push, a
	bor a, 0x7000
	set j, [video_cur]
	set [j], a
	add [video_cur], 1
	ife [video_cur], 0x9180
		jsr scroll
	set a, pop
	set j, pop
	set pc, pop

:getchar
	set push, a
	set a, 1
	:__getchar__loop
	hwi [keyboardID]
	ife c, 0
		set pc, __getchar__loop
	set a, pop
	set pc, pop
 
:backspace
	ife [max_backspace], [video_cur]
		set pc, pop
	sub [video_cur], 1
	set push, a
	set a, 0x20
	jsr printc
	set a, pop
	sub [video_cur], 1
	set pc, pop

:enter
        :enterStart
        set push, a
        set push, b
        set push, C
        set push, j
       
        set a, [video_cur]
        set b, 0x0020
        set C, [VRAM]
        add C, 0x160
        set j, a
        mod j, b
        sub a, j
        add a, 0x0020
        ifg a, [VRAM_end]
                set a, [VRAM]
        set [video_cur], a
        SET [max_backspace], A
        IFG [video_cur], C
        	JSR scroll
        set j, pop
        set C, pop
        set b, pop
        set a, pop
        :enterEnd
        SET PC, POP
        
:cmd_get_args
	set push, A
	set push, B
	set A, [max_backspace]
	SET [cmd_args_start], 0
	:cmd_get_args_loop
	set B, [A]
	and B, 0x7F
	ife B, 0x0
		set pc, cmd_get_args_end
	ife B, 0x20
		set pc, cmd_get_args_assign
	add A, 0x1
	set pc, cmd_get_args_loop
	:cmd_get_args_assign
	set [cmd_args_start], A
	add [cmd_args_start], 0x1
	:cmd_get_args_loop2
	set B, [A]
	and B, 0x7F
	ife B, 0x0
		set pc, cmd_get_args_end
	add A, 0x1
	set pc, cmd_get_args_loop2
	:cmd_get_args_end
	set [cmd_args_end], A
	sub [cmd_args_end], 0x1
	set B, pop
	set A, pop
	set pc, pop
 
:cmd_enter
		SET PUSH, A
		SET PUSH, B
		SET PUSH, C
		SET PUSH, Y
		SET PUSH, X
		SET X, 0
		JSR cmd_get_args
		SET A, [max_backspace]
		SET B, cmd_load
		JSR startswith
		IFE Y, 1
			JSR cmd_enter_load
		SET A, [max_backspace]
		SET B, cmd_ls
		JSR startswith
		IFE Y, 1
			JSR cmd_enter_ls
		SET A, [max_backspace]
		SET B, cmd_mkdir
		JSR startswith
		IFE Y, 1
			JSR cmd_enter_mkdir
		SET A, [max_backspace]
		SET B, cmd_help
		JSR startswith
		IFE Y, 1
			JSR cmd_enter_help
		SET A, [max_backspace]
		SEt B, cmd_version
		JSR startswith
		IFE Y, 1
			JSR cmd_enter_version
		SET A, [max_backspace]
		SET B, cmd_diskname
		JSR startswith
		IFE Y, 1
			JSR cmd_enter_diskname
		SET A, [max_backspace]
		SET B, cmd_format_datafloppy
		JSR startswith
		IFE Y, 1
			JSR cmd_enter_format_datafloppy
		SET A, [max_backspace]
		SET B, cmd_clear
		JSR startswith
		IFE Y, 1
			JSR cmd_enter_clear
		SET A, [max_backspace]
		SET B, cmd_echo
		JSR startswith
		IFE Y, 1
			JSR cmd_enter_echo			
		JSR enter
		IFE X, 0
			JSR cmd_enter_badcmd	
		SET X, POP
		SET Y, POP
		SET C, POP
		SET B, POP
		SET A, POP
		SET PC, POP
		
:cmd_enter_echo
		set push, A
		set push, B
		SET PUSH, Z
		IFE 0, [cmd_args_start]
			SET PC, cmd_enter_echo_end
		SET B, [cmd_args_start]
		SUB B, 1
		SET Z, 0
		set A, [cmd_args_end]
		SET PUSH, [A]
		SUB A, 1
		ADD Z, 1
		IFN B, A
			SUB PC, 5
		jsr enter
		SET A, POP
		jsr printc
		SUB Z, 1
		IFN Z, 0
			SUB PC, 6
		:cmd_enter_echo_end
		SET X, 1
		SET Z, POP
		set B, pop
		set A, pop
		set pc, pop
		
:cmd_enter_clear
		JSR clrscr
		SET [max_backspace], [VRAM]
		SET [video_cur], [VRAM]
		SET X, 1
		SET PC, POP
		
:cmd_enter_ls
		SET PUSH, A
		SET PUSH, B
		SET PUSH, C
		SET PUSH, I
		SET PUSH, Y
		SET PUSH, Z
		SET PUSH, J
		SET A, [folder_cur]
		SET I, 1
	:cmd_enter_ls_loop
		SET B, I
		JSR enter
		JSR fs_get_dir_entry
		IFE [A], 0x000
			SET PC, cmd_enter_ls_loop_end
		IFE A, 0
			SET PC, cmd_enter_ls_loop_end
		SET B, A
		SET A, 16
		JSR mem_alloc
		IFN A, 0
			ADD PC, 8
		SET A, txt_error
		SET B, 0x7000
		JSR print
		SET X, 1
		SET PC, POP
		
		SET [A], [B]
		ADD A, 1
		ADD B, 1
		SET [A], [B]
		ADD A, 1
		ADD B, 1
		SET [A], [B]
		ADD A, 1
		ADD B, 1
		SET [A], [B]
		ADD A, 1
		ADD B, 1
		SET [A], [B]
		SUB A, 4
		SET Y, A
		SET Z, Y
		JSR fat16_7bitTo16bit
		SET J, 0
	:cmd_enter_ls_loop2
		IFE [Z], 0
			ADD PC, 9
		BOR [Z], 0x7000
		SET A, [Z]
		JSR printc
		ADD Z, 1
		ADD J, 1
		IFN J, 0xC
			SUB PC, 11
			
		ADD I, 1
		SET A, Y
		JSR mem_free
		SET A, [folder_cur]
		SET PC, cmd_enter_ls_loop
		
		:cmd_enter_ls_loop_end
		
		SET J, POP
		SET Z, POP
		SET Y, POP
		SET I, POP
		SET C, POP
		SET B, POP
		SET A, POP
		SET X, 1
		SET PC, POP
		
:cmd_enter_mkdir
		SET A, [cmd_args_start]
		SET PUSH, Z
		SET PUSH, Y
		SET PUSH, I
		SET I, 0
		SET Z, A
		SET A, 16
		JSR mem_alloc
		SET PUSH, A
		IFN A, 0
			ADD PC, 12
		SET A, txt_error
		SET B, 0x7000
		JSR print
		SET A, POP
		SET I, POP
		SET Y, POP
		SET Z, POP
		SET X, 1
		SET PC, POP
		SET Y, A
		SET A, Z
		:cmd_enter_mkdir_loop
		SET Z, [A]
		IFE A, [cmd_args_end]
			SET PC, cmd_enter_mkdir_loop_end
		SET [Y], Z
		ADD A, 1
		ADD Y, 1
		ADD I, 1
		IFN I, 0xC
			SET PC, cmd_enter_mkdir_loop
		:cmd_enter_mkdir_loop_end
		SET I, PEEK
		SET Y, I
		JSR fat16_16bitTo7bit
		SET [Y], [J]
		ADD Y, 1
		ADD J, 1
		SET [Y], [J]
		ADD Y, 1
		ADD J, 1
		SET [Y], [J]
		ADD Y, 1
		ADD J, 1
		SET [Y], [J]
		ADD Y, 1
		ADD J, 1
		SET [Y], [J]
		ADD Y, 1
		ADD J, 1
		SET [Y], 0x800
		ADD Y, 1
		SET [Y], 0
		ADD Y, 1
		SET [Y], 0
		ADD Y, 1
		SET [Y], 0
		ADD Y, 1
		SET [Y], 0
		ADD Y, 1
		SET [Y], 0
		ADD Y, 1
		SET [Y], 0
		ADD Y, 1
		SET A, 1
		JSR fs_create_file
		SET [Y], A
		ADD Y, 1
		SET [Y], 0
		ADD Y, 1
		SET [Y], 1
		SET PUSH, C
		JSR fs_get_FAT_entry
		ADD Y, 1
		SET [Y], C
		SET C, POP
		SET B, PEEK
		SET A, PEEK
		JSR fs_add_dir_entry
		SET A, POP
		JSR mem_free
		SET I, POP
		SET Y, POP
		SET Z, POP
		SET X, 1
		SET PC, POP
		
:cmd_enter_load
		SET X, 1
		SET PUSH, A
		SET PUSH, B
		SET PUSH, X
		SET PUSH, C
		SET A, 0
		HWI [floppyID]
		IFE B, 1
			ADD PC, 0xA
		JSR enter
		SET A, txt_noDsk
		SET B, 0x7000
		JSR print
		SET PC, cmd_enter_load_exit
		
		SET A, 1
		HWI [floppyID]
		SET A, B
		JSR mem_alloc
		SET X, A
		SET A, 0x10
		SET B, 0
		SET C, 1
		HWI [floppyID]
		
		SET A, X
		JSR mem_free
		SET A, [X]
		IFN A, 0xCB82 ; If disk is OS disk
			ADD PC, 0xA
		JSR enter
		SET A, txt_bootDsk
		SET B, 0x7000
		JSR print
		SET PC, cmd_enter_load_exit
		
		:cmd_enter_load_exit
		SET C, POP
		SET X, POP
		SET B, POP
		SET A, POP
		SET PC, POP
		
:cmd_enter_help
		SET PUSH, A
		SET PUSH, Z
		JSR enter
		SET X, 1
		SET Z, txt_Availcmds
	:cmd_enter_help_startloop
		SET A, [Z]
		IFE A, 0
			SET PC, cmd_enter_help_startdone
		JSR printc
		ADD Z, 1
		SET PC, cmd_enter_help_startloop
	:cmd_enter_help_startdone
		ADD Z, 1
	:cmd_enter_help_cmdsloop
		SET A, [Z]
		IFE A, 0
			SET PC, cmd_enter_help_comma
		JSR printc
	    ADD Z, 1
		SET PC, cmd_enter_help_cmdsloop
	:cmd_enter_help_comma
		ADD Z, 1
		IFE [Z], 0x1234
			SET PC, cmd_enter_help_done
	    SET A, 0x2c
	    JSR printc
	    SET PC, cmd_enter_help_cmdsloop
	:cmd_enter_help_done
		SET Z, POP
		SET A, POP
		SET PC, POP
		
:cmd_enter_version
		SET X, 1
		JSR enter
		SET A, txt_version
		SET B, 0x7000
		JSR print
		SET PC, POP
		
:cmd_enter_badcmd
		SET A, txt_Badcmd
		SET B, 0x7000
		JSR print
		SET PC, POP
		
:cmd_enter_format_datafloppy
		;TODO: IMPLEMENT
		;notes: needs a atoi function to read a drive number, a check if that number is a drive, then read the second argument,
		;         which must be a string that is exactly 11 chars long (pad with spaces if longer)
		;         then call fat16_format_data_HMU1440 with these two things
		SET push, A
		SET push, B
		SET A, [floppyID]
		SET B, [max_backspace]
		ADD B, 18
		jsr fat16_format_data_HMU1440
		jsr enter
		SET A, txt_done
		SET B, 0x7000
		jsr print
		SET B, pop
		SET A, pop
		SET X, 1
		SET PC, POP

:cmd_enter_diskname
		SET push, A
		SET A, 11
		jsr mem_alloc
		ife A, 0
			set pc, .oom
		set push, A
		jsr fat16_diskname
		jsr enter
		set A, [sp]
		SET B, 0x7000
		jsr print
		set A, pop
		jsr mem_free
:.end	SET X, 1
		SET A, pop
		SET PC, POP
:.oom	SET A, txt_error
		SET B, 0x7000
		jsr print
		SET A, txt_oom
		jsr print
		set A, pop
		set pc, end

:read
		SET PUSH, A
		set push, b
		SET PUSH, C
        :readLoop
		set b, [video_cur]
        set [b], 0x709f ; white-on-black, blinking, full box
        JSR getChar
        set [b], 0
        ife c, 0x0011
        	set pc, readDone
        ifn c, 0x0010
        	set pc, not_backspace
        jsr backspace
        set pc, readLoop
        not_backspace:
        SET A, C
        JSR printc
        set pc, readLoop
        :readDone
        JSR cmd_enter
        SET C, POP
        set b, pop
        SET A, POP
        SET PC, POP
        
:startswith ; A is memory location of text, B is memory location of command, Y is return value
	SET PUSH, Z
	set y, 0
	
:startswithLoop

	ife [b], 0
	set pc, startswith_end_success
	
	SET Z, [A]
	
	XOR Z, 0x7000

    ifn z, [b]
    	SET PC, startswith_end_fail

	add a, 1
	add b, 1
	set pc, startswithLoop

	:startswith_end_success
		set y, 1
		SET Z, POP
		set pc, pop
	:startswith_end_fail
		SET Z, POP
		SET PC, POP
		
; Scrolls the screen one line
:scroll
	set push, i
	set push, j
	
	set i, [VRAM] ; Set I to the start of video memory
	set j, i
	add j, 0x20   ; Set J to one line down from I
	
	:__scroll__move_everything_one_line_up
	sti [i], [j]
	ifn j, 0x9181
		set pc, __scroll__move_everything_one_line_up
	
	:__scroll__clear_last_line
	sti [i], 0
	ifn i, 0x9181
		set pc, __scroll__clear_last_line
	
	sub [video_cur], 0x20
	sub [max_backspace], 0x20
	set j, pop
	set i, pop
	set pc, pop

:null   dat 0x0
:screen dat 0x0
:line   dat 0x0
