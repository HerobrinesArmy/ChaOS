; --------------------------------------------
; Title:   Calculator
; Author:  Bone Storm (HRSDL)
; Date:    8/10/2012
; Version: 0.1
; --------------------------------------------
	hwn i					; Get the list of attached hardware
	set j, 0				; Count
:loop
	hwq j					; Step 1: Get info
	ife a, 0xf615				; If monitor...
		set pc, display_detected
	ife a, 0x7406				; keyboard...
		set pc, keyboard_detected
	ife a, 0xb402				; clock...
		set pc, clock_detected
:continue
	add j, 1				; Count++
	ife j, i				; When finished iterating
		set pc, initialize_display	; Start setting up the display routine
	set pc, loop


:display_detected
	set [display_address], j		; set the address
	SET A, 0
	SET B, 0x8000
	HWI [display_address]
	set pc, continue			; then continue finding stuff
:keyboard_detected
	set [keyboard_address], j		; set the address
	set pc, continue			; then continue finding stuff
:clock_detected
	set [clock_address], j		; set the address
	set pc, continue			; then continue finding stuff

:initialize_display
SET PC, start
	
:display_address
DAT 0xFFFF
:keyboard_address
DAT 0xFFFF
:clock_address
DAT 0xFFFF

;The new calculator will not allow you to make mathematical errors like 6-+6 or 6//6 without creating an error.
;Also, you can now set the base to a number by adding a tag at the end of it (10h) for 10 in hex.
;The tags are i for b"i"nary, o for "o"ctal, t for "t"en, and h for "h"ex
;I couldn't use b or d as tags because it would cause confusion with hex's b and d.
;A new command "setDefaultBase" was also added. This will allow you to change the default base between the number 2 and 16. Always assigned in decimal
;So if I type, base 2, then type 10 on the next line, 2 would be the value since 10 in binary is 2.
;mod ( % ) operator was added.
;You can "double fib still" ( !!7 = !13 = 233)
;
;Example Used:
;Base is by default 10.
;!!7%fh^10i
;233%15^2
;8^2
;64


theData: dat "!!7%fh^10i",0xFFFF
setBaseLine: dat "base 10",0xFFFF
;By the release, these would be the same line

:subAndJump
SUB B,1
SET PC, loopNum1

:start
JSR setDefaultBase;This will execute when the user input has the first word "base", but for now, it will just execute at the start 
SET PUSH, 0;This allows the program to identify the end of the string due to the fact the stack can have random values
SET A,0
SET B,0
SET I,0

:BToEnd
ADD B,1
IFN [theData+B],0xFFFF
SET PC, BToEnd
SET PC, StartLoop
:StartLoop
SUB B,1
SET J,1;J will keep track of the digit place
JSR checkSuffix
SET Z, [theData+B]
IFE [theData+B],'h'
SET PC, subAndJump
SET Z, [theData+B]
IFE [theData+B], 'i'
SET PC, subAndJump
SET Z, [theData+B]
IFE [theData+B], 'o'
SET PC, subAndJump
SET Z, [theData+B]
IFE [theData+B], 't'
SET PC, subAndJump
:loopNum1
SET C, [theData+B]
;Check to see if the string is done
IFE B,-1
SET PC, calculate
;Check to see if there is an operation sign
IFE C, '!'
SET PC, fibA
IFE C, '-'
SET PC, pushA
IFE C, '+'
SET PC, pushA
IFE C, '*'
SET PC, pushA
IFE C, '/'
SET PC, pushA
IFE C, '^'
SET PC, pushA
IFE C, '%'
SET PC, pushA
;Check to see if C is a number
SET Z,1
IFE C, '1'
IFG [base],1
SET Z, 0
IFE C, '2'
IFG [base],2
SET Z, 0
IFE C, '3'
IFG [base],3
SET Z, 0
IFE C, '4'
IFG [base],4
SET Z, 0
IFE C, '5'
IFG [base],5
SET Z, 0
IFE C, '6'
IFG [base],6
SET Z, 0
IFE C, '7'
IFG [base],7
SET Z, 0
IFE C, '8'
IFG [base],8
SET Z, 0
IFE C, '9'
IFG [base],9
SET Z, 0
IFE C, '0'
SET Z, 0
IFE C, 'a'
IFG [base],10
SET Z, 0
IFE C, 'b'
IFG [base],11
SET Z, 0
IFE C, 'c'
IFG [base],12
SET Z, 0
IFE C, 'd'
IFG [base],13
SET Z, 0
IFE C, 'e'
IFG [base],14
SET Z, 0
IFE C, 'f'
IFG [base],15
SET Z, 0
IFE Z,1
SET PC, error
IFE c,'a'
SET c,0x3a
IFE c,'b'
SET c,0x3b
IFE c,'c'
SET c,0x3c
IFE c,'d'
SET c,0x3d
IFE c,'e'
SET c,0x3e
IFE c,'f'
SET c,0x3f
SUB C, 0x30
MUL C,J
MUL J,[base]
ADD A, C
SUB B, 1
SET PC, loopNum1

:checkSuffix
SET [base], [defaultBase]
IFE [theData+B], 'h'; h for "h"ex
SET [base], 16
IFE [theData+B], 'i'; i for b"i"nary
SET [base], 2
IFE [theData+B], 'o'; o for "o"ctal
SET [base], 8
IFE [theData+B], 't'; t for "t"en
SET [base], 10
SET PC, POP

:pushA
SET Z,1
SET Y,theData
SUB Y,1
ADD Y,B
SET Y,[Y]
IFE Y, '1'
IFG [base],1
SET Z, 0
IFE Y, '2'
IFG [base],2
SET Z, 0
IFE Y, '3'
IFG [base],3
SET Z, 0
IFE Y, '4'
IFG [base],4
SET Z, 0
IFE Y, '5'
IFG [base],5
SET Z, 0
IFE Y, '6'
IFG [base],6
SET Z, 0
IFE Y, '7'
IFG [base],7
SET Z, 0
IFE Y, '8'
IFG [base],8
SET Z, 0
IFE Y, '9'
IFG [base],9
SET Z, 0
IFE Y, '0'
SET Z, 0
IFE Y, 'a'
IFG [base],10
SET Z, 0
IFE Y, 'b'
IFG [base],11
SET Z, 0
IFE Y, 'c'
IFG [base],12
SET Z, 0
IFE Y, 'd'
IFG [base],13
SET Z, 0
IFE Y, 'e'
IFG [base],14
SET Z, 0
IFE Y, 'f'
IFG [base],15
SET Z, 0
IFE Y, 'h'
SET Z, 0
IFE Y, 't'
SET Z, 0
IFE Y, 'i'
SET Z, 0
IFE Y, 'o'
SET Z, 0
IFE Z,1
SET PC, error

SET PUSH, A
SET PUSH, C
SET A,0
SET PC, StartLoop

:calculate
:calculateLoop
SET I, POP
SET B, POP
IFE I,0
SET PC,print
IFE I, '+'
ADD A,B
IFE I, '-'
SUB A,B
IFE I, '*'
MUL A,B
IFE I, '/'
DIV A,B
IFE I, '^'
JSR AToTheBPower
IFE I, '%'
MOD A,B
SET PC,calculateLoop

:fibA
SET PUSH, Z
SET Z,1
IFE B,0
SET Z, 0
SET I,theData
SUB I,1
ADD I,B
SET I,[I]
IFE I, '!'
SET Z,0
IFE I, '^'
SET Z,0
IFE I, '*'
SET Z,0
IFE I, '/'
SET Z,0
IFE I, '+'
SET Z,0
IFE I, '-'
SET Z,0
IFE Z, '%'
SET Z,0
IFE Z,1
SET PC, fibError
SET Z, POP
SET PUSH, J
SET PUSH, X;prev
SET PUSH, Y;result
SET PUSH, Z;sum
SET J, 0xFFFF
SET X,0xFFFF
SET Y,1
SET Z,0
IFE A,1
SET PC, fibEnd1or0
IFL A,1
SET PC, fibEnd1or0
SUB A,1
:fibLoop
ADD J,1
SET Z,0
ADD Z,X
ADD Z,Y
SET X,Y
SET Y,Z
IFG J,A
SET PC, fibEnd
SET PC,fibLoop

:fibEnd1or0
SET Z, POP
SET Y, POP
SET X, POP
SET J, POP
SUB B, 1
SET PC, loopNum1

:fibEnd
SET A, Y
SET Z, POP
SET Y, POP
SET X, POP
SET J, POP
SUB B, 1
SET PC, loopNum1


:AToTheBPower

IFE B, 0
SET PC, powEnd0
IFL B, 0
SET PC, powEndLess0
SET C,A

SET PUSH, C

:powLoop
IFE B,1
SET PC, powEnd
SUB B,1
MUL A,C
SET PC, powLoop

IFE B, 0
SET PC, powEnd0
IFL B, 0
SET PC, powEndLess0

:powEnd0
SET PC, POP

:powEndLess0
SET A, 0
SET PC,POP

:powEnd
SET C,POP
SET PC, POP

:fibError
SET Z,POP
SET PC, error

:error
SET I,0
:errorLoop
SET C, [errorTXT+I]
IFE C,0x0000
SET PC,end
ADD C,0xF000
SET [0x8000+I],C
ADD I, 1
SET PC,errorLoop

:print
SET J,10000;Place Counter
SET I,0x8000;Screen Counter
:printLoop
SET B, A
DIV B, J
DIV J, 10
IFE J,0xFFFF;This is the value of "0x0000/10" No idea why
SET PC,end
IFE B,0
SET PC, printLoop
IFG B, 9
MOD B, 10
ADD B,0xF030
SET [I], B
ADD I,1
SET PC,printLoop

:end;In the future, end will just wait for the user's next input
SET PC,end

:setDefaultBase;Will always be calculated in base 10 and cannot go below base 2 or above base 16
SET I, setBaseLine
SET A,0
SET J,1
:setToLastForBase
IFE [I],0xFFFF
SET PC, continueSetBase
ADD I,1
SET PC, setToLastForBase
:continueSetBase
SUB I,1
IFE [I], ' '
SET PC, endBase
SET C, [I]
SET Z,1
IFE C, '1'
SET Z, 0
IFE C, '2'
SET Z, 0
IFE C, '3'
SET Z, 0
IFE C, '4'
SET Z, 0
IFE C, '5'
SET Z, 0
IFE C, '6'
SET Z, 0
IFE C, '7'
SET Z, 0
IFE C, '8'
SET Z, 0
IFE C, '9'
SET Z, 0
IFE C, '0'
SET Z, 0
IFE Z,1
SET PC, error
SUB C, 0x30
MUL C, J
MUL J, 10
ADD A,C
SET PC, continueSetBase

:endBase
IFG A,16
SET PC, error
IFL A,2
SET PC, error
SET [defaultBase], A
SET PC, POP

:errorTXT dat "GENERIC ERROR. A SPECIFIC ERROR IS NEEDED HERE.", 0x0000

:defaultBase dat 10
:base dat 0x0000

